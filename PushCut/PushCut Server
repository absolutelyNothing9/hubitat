/**
 * Pushcut Ultimate Integration - PARENT APP
 * * Logic:
 * - Manages API Keys and Inbound Webhooks.
 * - Creates Child Devices representing Physical iOS Devices.
 * - Routes commands from Child Devices to the Pushcut API with specific device targeting.
 */

definition(
    name: "Pushcut Ultimate Integration",
    namespace: "absolutelyNothing9",
    author: "absolutelyNothing9",
    description: "Server and Device Manager for Pushcut. Creates devices representing your Phones/iPads.",
    category: "My Apps",
    oauth: true,
    iconUrl: "",
    iconX2Url: ""
)

mappings {
    path("/pushcut/command") { action: [ GET: "handlePushcutCommand", POST: "handlePushcutCommand" ] }
}

preferences {
    page(name: "mainPage")
    page(name: "addChildPage")
}

def mainPage() {
    return dynamicPage(name: "mainPage", title: "Pushcut Configuration", install: true, uninstall: true) {
        section("API & Security") {
            input "pushcutApiKey", "password", title: "Pushcut API Key (For Outbound)", required: true
            input "userSecret", "password", title: "Webhook Secret (For Inbound Server)", required: true
        }

        section("Inbound Server (Receive from Pushcut)") {
            if (state.accessToken) {
                def url = "${getFullApiServerUrl()}/pushcut/command?access_token=${state.accessToken}&secret=${userSecret}"
                paragraph "Use this URL in Pushcut 'Server Actions' to control Hubitat:\n\n**${url}**"
            } else {
                paragraph "Click 'Done' and re-open to generate your Webhook URL."
            }
            input "authorizedDevices", "capability.switch", title: "Devices Pushcut can control", multiple: true, required: false
        }
        
        section("Managed iOS Devices") {
            paragraph "Create a virtual device for every physical iPhone or iPad in your Pushcut account."
            href(name: "addChildLink", title: "Add New iOS Device", page: "addChildPage")
            
            def children = getChildDevices()
            if (children) {
                children.each { child -> paragraph "Device: **${child.label}** (ID: ${child.deviceNetworkId})" }
            }
        }
    }
}

def addChildPage() {
    return dynamicPage(name: "addChildPage", title: "Add iOS Device") {
        section {
            input "newDeviceName", "text", title: "Device Label (e.g., John's iPhone)", required: true
            input "pushcutDeviceName", "text", title: "Pushcut Device Name", description: "Must match the device name in Pushcut Settings exactly.", required: true
        }
        section {
            action(name: "createNewDevice", title: "Create Device Now", action: "createChild")
        }
    }
}

// =================================================================
// ðŸš¨ INBOUND SERVER LOGIC (Receiving commands from iOS)
// =================================================================

def handlePushcutCommand() {
    def params = request.JSON ?: request.getParams()
    
    if (params.secret != userSecret) {
        log.warn "Pushcut Server: Unauthorized secret mismatch."
        return httpError(401, "Unauthorized")
    }

    def command = params.command?.toUpperCase()
    def deviceName = params.device
    def value = params.value 
    
    def target = authorizedDevices.find { it.label == deviceName }
    if (!target) return httpError(404, "Device not authorized or found.")

    log.info "Pushcut Server: Executing ${command} on ${deviceName}"
    
    switch (command) {
        case "ON": target.on(); break
        case "OFF": target.off(); break
        case "TOGGLE": target.currentSwitch == "on" ? target.off() : target.on(); break
        case "SETLEVEL": if (value) target.setLevel(value.toInteger()); break
        default: log.warn "Unknown command: ${command}"; break
    }

    return httpResponse(status: 200, data: [status: "success"])
}

// =================================================================
// â¬†ï¸ OUTBOUND LOGIC (Sending data to iOS)
// =================================================================

/**
 * Sends a notification request to the Pushcut API, targeting a specific device.
 */
def sendPushcutNotification(targetDeviceName, notificationName, title, text, inputStr, sound, image) {
    def body = [
        title: title,
        text: text,
        input: inputStr,
        sound: sound,
        image: image,
        devices: [targetDeviceName] // ðŸ‘ˆ Targets specific device
    ].findAll { k, v -> v != null && v != "" }
    
    sendPushcutRequest("notifications/${notificationName}", body)
}

/**
 * Sends a widget update request to the Pushcut API, targeting a specific device.
 */
def updatePushcutWidget(targetDeviceName, widgetName, contentMap, inputsMap, onTap) {
    def body = [
        content: contentMap,
        inputs: inputsMap,
        onTap: onTap,
        devices: [targetDeviceName] // ðŸ‘ˆ Targets specific device
    ].findAll { k, v -> v != null && v != "" && v != [:] }

    sendPushcutRequest("widgets/${widgetName}", body)
}

private sendPushcutRequest(endpoint, body) {
    def params = [
        uri: "https://api.pushcut.io/v1/${endpoint}",
        body: body,
        headers: ["API-Key": pushcutApiKey, "Content-Type": "application/json"]
    ]
    asynchttpPost("handlePushcutResponse", params)
}

def handlePushcutResponse(response, data) {
    if (response.status != 200) {
        log.error "Pushcut API Error: ${response.status} - ${response.errorMessage}"
    }
}

// =================================================================
// CHILD DEVICE MANAGEMENT
// =================================================================

def createChild() {
    // DNI uses the Pushcut Device Name to ensure uniqueness per physical device
    def dni = "Pushcut-Mobile-${pushcutDeviceName}"
    
    if (!getChildDevice(dni)) {
        addChildDevice("absolutelyNothing", "Pushcut Mobile Device", dni, [
            label: newDeviceName,
            data: [pushcutTarget: pushcutDeviceName]
        ])
    }
}

def installed() { initialize() }
def updated() { initialize() }
def initialize() { if (!state.accessToken) createAccessToken() }
